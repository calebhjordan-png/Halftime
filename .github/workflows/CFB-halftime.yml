// cfb-halftime-watcher.mjs
// Purpose: For today's CFB games, detect HALFTIME and, for each game that just hit half,
// fetch Half Score (API) + Live Odds (DOM + API fallbacks) and write them ONCE to your sheet.
//
// Requires: npm i googleapis undici playwright dotenv
// Env:
//   GOOGLE_SHEET_ID          -> target Google Sheet ID
//   GOOGLE_SERVICE_ACCOUNT   -> service account JSON (raw or base64)
//   TAB_NAME                 -> "CFB" (default)
//   MAX_RUNTIME_MIN          -> optional (default 120) safety cap for the loop
//
// Sheet headers expected (case-insensitive; auto-created if missing):
//   Date (ET) | Week | Status | Matchup | Half Score | Final Score |
//   Live Away Spread | Live Away ML | Live Home Spread | Live Home ML | Live Total

import 'dotenv/config';
import { google } from 'googleapis';
import { fetch } from 'undici';
import { chromium } from 'playwright';

const SHEET_ID  = need('GOOGLE_SHEET_ID');
const CREDS_RAW = need('GOOGLE_SERVICE_ACCOUNT');
const TAB_NAME  = process.env.TAB_NAME || 'CFB';
const MAX_RUNTIME_MIN = Number(process.env.MAX_RUNTIME_MIN || 120);

const ET_TZ = 'America/New_York';
const COLS = [
  'Date (ET)','Week','Status','Matchup',
  'Half Score','Final Score',
  'Live Away Spread','Live Away ML',
  'Live Home Spread','Live Home ML','Live Total'
];

function need(k){ const v = (process.env[k]||'').trim(); if(!v) throw new Error(`Missing env ${k}`); return v; }
function parseSA(raw){ return raw.trim().startsWith('{') ? JSON.parse(raw) : JSON.parse(Buffer.from(raw,'base64').toString('utf8')); }
function lowerMap(arr){ const m={}; arr.forEach((v,i)=>m[String(v||'').toLowerCase()]=i); return m; }
function colA1(n){ let s='',x=n; while(x>0){ const m=(x-1)%26; s=String.fromCharCode(65+m)+s; x=Math.floor((x-1)/26);} return s; }
function truthy(v){ return v!==undefined && v!==null && String(v).trim()!==''; }

function fmtETDate(dlike){
  return new Intl.DateTimeFormat('en-US',{timeZone:ET_TZ,year:'numeric',month:'numeric',day:'numeric'}).format(new Date(dlike));
}
function yyyymmddET(d=new Date()){
  const p=new Intl.DateTimeFormat('en-US',{timeZone:ET_TZ,year:'numeric',month:'2-digit',day:'2-digit'}).formatToParts(d);
  const g=k=>p.find(x=>x.type===k)?.value||''; return `${g('year')}${g('month')}${g('day')}`;
}

// ---------- ESPN URLs ----------
const SPORT = 'football/college-football';
const SB_URL = (dates)=>`https://site.api.espn.com/apis/site/v2/sports/${SPORT}/scoreboard?dates=${dates}&groups=80&limit=300`;
const SUM_URL = (id)=>`https://site.api.espn.com/apis/site/v2/sports/${SPORT}/summary?event=${id}`;
const GAME_URL= (id)=>`https://www.espn.com/college-football/game?gameId=${id}`;

async function fetchJson(url){
  const r=await fetch(url,{headers:{'User-Agent':'halftime-watcher'}});
  if(!r.ok) throw new Error(`HTTP ${r.status} ${url}`);
  return r.json();
}

// ---------- Google Sheets ----------
async function getSheets(){
  const CREDS=parseSA(CREDS_RAW);
  const auth = new google.auth.JWT(CREDS.client_email,undefined,CREDS.private_key,['https://www.googleapis.com/auth/spreadsheets']);
  await auth.authorize();
  return google.sheets({version:'v4',auth});
}
async function ensureHeaderAndMap(sheets){
  // ensure tab exists
  const meta = await sheets.spreadsheets.get({ spreadsheetId: SHEET_ID });
  const wantTab = meta.data.sheets?.find(s=>s.properties?.title===TAB_NAME);
  if(!wantTab){
    await sheets.spreadsheets.batchUpdate({
      spreadsheetId: SHEET_ID,
      requestBody:{ requests:[{ addSheet:{ properties:{ title:TAB_NAME } } }] }
    });
  }
  // ensure headers
  const read = await sheets.spreadsheets.values.get({ spreadsheetId:SHEET_ID, range:`${TAB_NAME}!A1:ZZ1` });
  let header = read.data.values?.[0] || [];
  const seen = new Set(header.map(h=>String(h||'').toLowerCase()));
  for(const h of COLS){ if(!seen.has(h.toLowerCase())) header.push(h); }
  await sheets.spreadsheets.values.update({
    spreadsheetId:SHEET_ID,
    range:`${TAB_NAME}!A1:${colA1(header.length)}1`,
    valueInputOption:'RAW',
    requestBody:{ values:[header] }
  });
  const hmap = lowerMap(header);
  return { header, hmap };
}
async function readGrid(sheets){
  const grid = await sheets.spreadsheets.values.get({ spreadsheetId:SHEET_ID, range:`${TAB_NAME}!A1:ZZ` });
  return grid.data.values || [];
}
async function batchUpdate(sheets, updates){
  if(!updates.length) return;
  await sheets.spreadsheets.values.batchUpdate({
    spreadsheetId:SHEET_ID,
    requestBody:{ valueInputOption:'RAW', data: updates }
  });
}

// ---------- Helpers for row key ----------
function keyOf(dateET, matchup){ return `${(dateET||'').trim()}__${(matchup||'').trim()}`; }

// ---------- ESPN parsing ----------
function normalizeStatus(evt){
  const name = evt?.competitions?.[0]?.status?.type?.name || evt?.status?.type?.name || '';
  const short= evt?.competitions?.[0]?.status?.type?.shortDetail || '';
  if(/final/i.test(name)||/\bFinal\b/i.test(short)) return 'Final';
  if(/\bHalftime\b/i.test(short)) return 'Halftime';
  if(/inprogress|status\.in/i.test(name)||/\bQ[1-4]\b/i.test(short)) return 'Live';
  if(/pre|scheduled/i.test(name)||/\bScheduled\b/i.test(short)) return 'Scheduled';
  return name || 'Scheduled';
}
function namesFor(evt){
  const comp = evt?.competitions?.[0] || {};
  const away = comp.competitors?.find(c=>c.homeAway==='away');
  const home = comp.competitors?.find(c=>c.homeAway==='home');
  const awayName = away?.team?.shortDisplayName || away?.team?.abbreviation || away?.team?.name || 'Away';
  const homeName = home?.team?.shortDisplayName || home?.team?.abbreviation || home?.team?.name || 'Home';
  return {away,home,awayName,homeName};
}
async function halfScoreFromSummary(gameId){
  try{
    const sum = await fetchJson(SUM_URL(gameId));
    const comp0 = sum?.competitions?.[0];
    const comps = Array.isArray(comp0?.competitors) ? comp0.competitors : [];
    const awayC = comps.find(c=>c.homeAway==='away');
    const homeC = comps.find(c=>c.homeAway==='home');
    const toNum = v => { const n=Number(v?.value ?? v); return Number.isFinite(n)?n:0; };
    const sumH1 = arr => Array.isArray(arr) ? toNum(arr[0])+toNum(arr[1]) : 0;
    const aH1 = sumH1(awayC?.linescores || awayC?.linescore || awayC?.scorebreakdown);
    const hH1 = sumH1(homeC?.linescores || homeC?.linescore || homeC?.scorebreakdown);
    if(Number.isFinite(aH1) && Number.isFinite(hH1)) return `${aH1}-${hH1}`;
  }catch(e){}
  return '';
}

async function liveOddsSnapshot(gameId){
  // Try DOM first (best for spread/ML/total). Fall back to summary odds if needed.
  let awaySpread='', homeSpread='', total='', awayML='', homeML='';
  let halfScore='';

  const browser = await chromium.launch({ headless:true });
  const page = await browser.newPage();
  try{
    await page.goto(GAME_URL(gameId), { waitUntil:'domcontentloaded', timeout:60000 });
    await page.waitForLoadState('networkidle', { timeout:6000 }).catch(()=>{});
    // Half score from API (robust)
    halfScore = await halfScoreFromSummary(gameId);

    // LIVE ODDS block
    const section = page.locator('section:has-text("Live Odds"), section:has-text("LIVE ODDS"), [data-testid*="odds"]').first();
    if(await section.count()){
      const txt = (await section.innerText()).replace(/\u00a0/g,' ').replace(/\s+/g,' ').trim();
      // Spread heuristics (first two signed numbers are usually AWAY, HOME spreads)
      const spreadMatches = txt.match(/[+-]\d+(?:\.\d+)?/g) || [];
      awaySpread = spreadMatches[0] || '';
      homeSpread = spreadMatches[1] || '';
      // Totals (O 62.5 / U 62.5 patterns)
      const tO = txt.match(/\bO\s?(\d+(?:\.\d+)?)\b/i);
      const tU = txt.match(/\bU\s?(\d+(?:\.\d+)?)\b/i);
      total = (tO && tO[1]) || (tU && tU[1]) || '';
      // Moneylines (signed 2–4 digits)
      const mls = txt.match(/[+-]\d{2,4}\b/g) || [];
      awayML = mls[0] || '';
      homeML = mls[1] || '';
    }

    // If any fields still missing, try summary odds/pickcenter
    if(!(awayML && homeML) || !total || !(awaySpread && homeSpread)){
      try{
        const sum = await fetchJson(SUM_URL(gameId));
        const oddsBuckets = [];
        const h = sum?.header?.competitions?.[0]?.odds; if(Array.isArray(h)) oddsBuckets.push(...h);
        if(Array.isArray(sum?.odds)) oddsBuckets.push(...sum.odds);
        if(Array.isArray(sum?.pickcenter)) oddsBuckets.push(...sum.pickcenter);
        const first = oddsBuckets.find(Boolean) || {};
        const favId = String(first?.favorite ?? first?.favoriteTeamId ?? '');
        const spread = Number(first?.spread ?? (typeof first?.details==='string'
          ? parseFloat((first.details.match(/([+-]?\d+(?:\.\d+)?)/)||[])[1]) : NaN));
        const ou = first?.overUnder ?? first?.total;
        if(!total && ou) total = String(ou);

        const comps = sum?.competitions?.[0]?.competitors || [];
        const awayId = String(comps.find(c=>c.homeAway==='away')?.id || '');
        const homeId = String(comps.find(c=>c.homeAway==='home')?.id || '');

        // Moneyline extraction (cover several shapes)
        const mlFields = cand=>{
          let a='',h='';
          const tryNum = v=> (v==null? '': (isNaN(+v)? '': String(v)));
          a = tryNum(cand?.moneyLineAway ?? cand?.awayTeamMoneyLine ?? cand?.awayMoneyLine);
          h = tryNum(cand?.moneyLineHome ?? cand?.homeTeamMoneyLine ?? cand?.homeMoneyLine);
          if(!(a&&h) && Array.isArray(cand?.teamOdds)){
            for(const t of cand.teamOdds){
              const id = String(t?.teamId ?? t?.team?.id ?? '');
              const ml = tryNum(t?.moneyLine ?? t?.moneyline ?? t?.money_line);
              if(id===awayId && ml) a=a||ml;
              if(id===homeId && ml) h=h||ml;
            }
          }
          return {a,h};
        };
        if(!(awayML&&homeML)){
          const {a,h} = mlFields(first);
          if(a) awayML = awayML || a;
          if(h) homeML = homeML || h;
          if(!(awayML&&homeML) && Array.isArray(oddsBuckets)){
            for(const b of oddsBuckets){
              const {a:aa,h:hh} = mlFields(b);
              if(!awayML && aa) awayML=aa;
              if(!homeML && hh) homeML=hh;
              if(awayML && homeML) break;
            }
          }
        }

        // Spread from favorite + number
        if(!(awaySpread && homeSpread) && favId && Number.isFinite(spread)){
          if(awayId===favId){ awaySpread = awaySpread || `-${Math.abs(spread)}`; homeSpread = homeSpread || `+${Math.abs(spread)}`; }
          else if(homeId===favId){ homeSpread = homeSpread || `-${Math.abs(spread)}`; awaySpread = awaySpread || `+${Math.abs(spread)}`; }
        }
      }catch(e){}
    }
  }catch(e){
    console.warn('DOM odds scrape failed:', e?.message||e);
  }finally{
    await page.close().catch(()=>{});
    await browser.close().catch(()=>{});
  }

  return { halfScore, awaySpread, homeSpread, awayML, homeML, total };
}

// ---------- Main loop ----------
(async function main(){
  const sheets = await getSheets();
  const { header, hmap } = await ensureHeaderAndMap(sheets);

  const start = Date.now();
  const hardStop = start + MAX_RUNTIME_MIN*60*1000;

  while(true){
    // 1) Load today's events once per loop
    const d = yyyymmddET(new Date());
    const sb = await fetchJson(SB_URL(d));
    let events = (sb?.events||[]).slice();
    // dedupe just in case
    const seen=new Set(); events = events.filter(e=>!seen.has(e.id)&&seen.add(e.id));

    // 2) Snapshot sheet rows to map date+matchup -> row
    const grid = await readGrid(sheets);
    const head = grid[0] || header;
    const rows = grid.slice(1);
    const hm = lowerMap(head);
    const idxDate = hm['date (et)'], idxMu = hm['matchup'];
    const idxStatus = hm['status'];
    const idxHalf  = hm['half score'];
    const idxLAsp  = hm['live away spread'];
    const idxLAml  = hm['live away ml'];
    const idxLHsp  = hm['live home spread'];
    const idxLHml  = hm['live home ml'];
    const idxTot   = hm['live total'];
    const rowIndex = new Map();
    rows.forEach((r,i)=>{
      const k = keyOf((r[idxDate]||''),(r[idxMu]||''));
      if(k.trim()) rowIndex.set(k, i+2);
    });

    let wrote = 0;
    const writes = [];

    for(const ev of events){
      const status = normalizeStatus(ev);
      const { away, home, awayName, homeName } = namesFor(ev);
      const matchup = `${awayName} @ ${homeName}`;
      const dateET  = fmtETDate(ev.date);
      const key     = keyOf(dateET, matchup);
      const rowNum  = rowIndex.get(key);
      if(!rowNum) continue; // only write to existing rows

      const r = rows[rowNum-2] || [];
      const haveHalf = truthy(r[idxHalf]);
      const haveOdds = truthy(r[idxLAsp]) || truthy(r[idxLAml]) || truthy(r[idxLHsp]) || truthy(r[idxLHml]) || truthy(r[idxTot]);

      // Only act when the game is at halftime and we haven't written yet
      if(status === 'Halftime' && (!haveHalf || !haveOdds)){
        const snap = await liveOddsSnapshot(ev.id);
        const add = (colIdx,val)=>{
          if(colIdx==null || colIdx<0) return;
          if(!truthy(val)) return;
          const range = `${TAB_NAME}!${colA1(colIdx+1)}${rowNum}:${colA1(colIdx+1)}${rowNum}`;
          writes.push({ range, values:[[val]] });
        };
        // ensure status shows Halftime
        add(idxStatus, 'Halftime');
        add(idxHalf,  snap.halfScore);
        add(idxLAsp,  snap.awaySpread);
        add(idxLAml,  snap.awayML);
        add(idxLHsp,  snap.homeSpread);
        add(idxLHml,  snap.homeML);
        add(idxTot,   snap.total);
      }
    }

    if(writes.length){
      await batchUpdate(sheets, writes);
      wrote = writes.length;
      console.log(`✅ wrote ${wrote} cell(s) this loop`);
    }else{
      console.log('…no halftime writes this loop');
    }

    // loop control
    const elapsed = Date.now() - start;
    if(Date.now() > hardStop){
      console.log('⏹ Reached MAX_RUNTIME_MIN, exiting.');
      break;
    }

    // Simple cadence: check every 3 minutes; you can tune this.
    await new Promise(r=>setTimeout(r, 3*60*1000));
  }

  console.log('Done.');
})().catch(e=>{ console.error('Fatal:', e?.stack||e); process.exit(1); });
