name: NFL Live

on:
  workflow_dispatch: {}
  schedule:
    # Top of the hour windows (adjust to your timezone needs)
    - cron: "0 14-23 * * *"   # 10:00–19:00 ET if EDT (UTC-4)
    - cron: "0 0-6 * * *"     # 20:00–02:00 ET if EDT (UTC-4)

concurrency:
  group: nfl-live-${{ github.ref }}
  cancel-in-progress: false

jobs:
  live:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    env:
      LEAGUE: nfl
      TAB_NAME: NFL
      GOOGLE_SHEET_ID: ${{ secrets.GOOGLE_SHEET_ID }}
      GOOGLE_SERVICE_ACCOUNT: ${{ secrets.GOOGLE_SERVICE_ACCOUNT }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      # Install repo deps AND make sure googleapis + playwright exist
      - name: Install deps (repo)
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm i
          fi
          npm i googleapis playwright

      # Install Playwright browser binaries (Chromium) for the scrape fallback
      - name: Install Playwright browsers (Chromium only)
        run: npx playwright install --with-deps chromium

      # Robust ID collector: don’t rely on Date only; include rows with live-ish Status
      - name: Collect today’s Game IDs from sheet (robust)
        id: ids
        shell: bash
        env:
          GOOGLE_SHEET_ID: ${{ env.GOOGLE_SHEET_ID }}
          GOOGLE_SERVICE_ACCOUNT: ${{ env.GOOGLE_SERVICE_ACCOUNT }}
          TAB_NAME: ${{ env.TAB_NAME }}
        run: |
          node - <<'NODE'
          const { google } = require("googleapis");
          const { appendFileSync } = require("node:fs");

          const SHEET_ID = process.env.GOOGLE_SHEET_ID;
          const SA = JSON.parse(process.env.GOOGLE_SERVICE_ACCOUNT);
          const TAB = process.env.TAB_NAME || "NFL";
          const ET = "America/New_York";

          const fmt = new Intl.DateTimeFormat("en-US", {
            timeZone: ET, year: "numeric", month: "2-digit", day: "2-digit"
          });

          function parseMDY(s) {
            const m = /^(\d{1,2})\/(\d{1,2})\/(\d{2}|\d{4})$/.exec(String(s || "").trim());
            if (!m) return null;
            let [ , mm, dd, yy ] = m;
            let y = yy.length === 2 ? 2000 + Number(yy) : Number(yy);
            return new Date(`${y}-${mm.padStart(2,"0")}-${dd.padStart(2,"0")}T12:00:00-05:00`);
          }
          function todayEt() {
            const parts = fmt.formatToParts(new Date());
            const g = k => parts.find(p => p.type === k)?.value || "00";
            return new Date(`${g("year")}-${g("month")}-${g("day")}T12:00:00-05:00`);
          }
          function withinDays(d, center, k=2) {
            if (!d) return false;
            const ms = 24*60*60*1000;
            const diff = Math.abs((d - center) / ms);
            return diff <= k;
          }

          const LIVE_RE = /(?:\bQ[1-4]\b|\bHalf\b|\d{1,2}:\d{2}\s*-\s*(?:1st|2nd|3rd|4th)|\bEnd\b|\bStart\b)/i;

          (async () => {
            const auth = new google.auth.JWT(
              SA.client_email, null, SA.private_key,
              ["https://www.googleapis.com/auth/spreadsheets"]
            );
            await auth.authorize();
            const sheets = google.sheets({ version: "v4", auth });

            const r = await sheets.spreadsheets.values.get({
              spreadsheetId: SHEET_ID,
              range: `${TAB}!A1:Z2000`,
            });
            const rows = r.data.values || [];
            if (!rows.length) { appendFileSync(process.env.GITHUB_OUTPUT, `list=[]\n`); return; }

            const header = rows[0] || [];
            const lower = s => (s || "").trim().toLowerCase();
            const h = Object.fromEntries(header.map((x,i)=>[lower(x), i]));

            const iA = h["game id"];      // A
            const iDate = h["date"];      // B
            const iStatus = h["status"];  // D (typically)

            if (iA == null) { appendFileSync(process.env.GITHUB_OUTPUT, `list=[]\n`); return; }

            const today = todayEt();
            const ids = [];

            for (let r = 1; r < rows.length; r++) {
              const row = rows[r] || [];
              const gid = (row[iA] || "").toString().trim();
              if (!gid) continue;

              const status = iStatus != null ? String(row[iStatus] || "").trim() : "";
              if (/^final$/i.test(status)) continue;

              const looksLive = LIVE_RE.test(status);
              let inWindow = false;
              if (iDate != null) {
                const d = parseMDY(row[iDate]);
                inWindow = withinDays(d, today, 2);
              }

              if (looksLive || inWindow) ids.push(gid);
            }

            appendFileSync(process.env.GITHUB_OUTPUT, `list=${JSON.stringify(ids)}\n`);
            console.log("TODAY_IDS=" + ids.join(","));
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

      # Run live-game once per Game ID, in parallel. Includes DEBUG_ODDS + forced Status write.
      - name: Run live-game oneshot for each ID in parallel (with odds debug)
        if: steps.ids.outputs.list != '[]'
        shell: bash
        env:
          LEAGUE: ${{ env.LEAGUE }}
          TAB_NAME: ${{ env.TAB_NAME }}
          GOOGLE_SHEET_ID: ${{ env.GOOGLE_SHEET_ID }}
          GOOGLE_SERVICE_ACCOUNT: ${{ env.GOOGLE_SERVICE_ACCOUNT }}
          IDS_JSON: ${{ steps.ids.outputs.list }}
          ONESHOT: "true"
          DEBUG_ODDS: "true"
          FORCE_STATUS_WRITE: "true"
        run: |
          ids=$(node -e "process.stdout.write(process.env.IDS_JSON||'[]')")
          node -e "
            const ids = JSON.parse(process.argv[1]||'[]');
            if (!ids.length) process.exit(0);
            (async () => {
              const { spawn } = await import('node:child_process');
              const procs = ids.map(id => new Promise((res, rej) => {
                const p = spawn('node',['live-game.mjs'],{
                  stdio:'inherit',
                  env:{ ...process.env, TARGET_GAME_ID:String(id) }
                });
                p.on('exit', c => c===0 ? res() : rej(new Error('exit '+c)));
              }));
              await Promise.allSettled(procs);
            })().catch(e => { console.error(e); process.exit(1); });
          " "$ids"
