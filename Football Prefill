// orchestrator.mjs
import { google } from "googleapis";
import axios from "axios";

/* =========================
   ENV / CONFIG
========================= */
const SHEET_ID  = (process.env.GOOGLE_SHEET_ID || "").trim();
const CREDS_RAW = (process.env.GOOGLE_SERVICE_ACCOUNT || "").trim();

const LEAGUE    = (process.env.LEAGUE || "nfl").toLowerCase();              // "nfl" | "college-football"
const TAB_NAME  = (process.env.TAB_NAME || (LEAGUE === "nfl" ? "NFL" : "CFB")).trim();
const RUN_SCOPE = (process.env.RUN_SCOPE || "week").toLowerCase();          // "today" | "week"
const TARGET_ID_RAW = (process.env.TARGET_GAME_ID || "").trim();            // "401772816,401772924" (optional)
const GHA_JSON  = String(process.env.GHA_JSON || "") === "1";

const ET_TZ = "America/New_York";

/* =========================
   LOGGING
========================= */
const _out = (s, ...a) => s.write(a.map(x => typeof x === "string" ? x : String(x)).join(" ") + "\n");
const log  = (...a) => GHA_JSON ? _out(process.stderr, ...a) : console.log(...a);
const warn = (...a) => GHA_JSON ? _out(process.stderr, ...a) : console.warn(...a);

/* =========================
   GOOGLE AUTH
========================= */
function parseServiceAccount(raw) {
  if (!raw) throw new Error("GOOGLE_SERVICE_ACCOUNT is empty");
  if (raw.trim().startsWith("{")) return JSON.parse(raw);
  return JSON.parse(Buffer.from(raw, "base64").toString("utf8"));
}

/* =========================
   DATE/TIME HELPERS
========================= */
function fmtETDateYYYYMMDD(d) {
  const parts = new Intl.DateTimeFormat("en-US", {
    timeZone: ET_TZ,
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  }).formatToParts(new Date(d));
  const get = k => parts.find(p => p.type === k)?.value || "";
  return `${get("year")}${get("month")}${get("day")}`;
}
function fmtETDateMDY(d) {
  // show Date in B col (10/26/2025)
  return new Intl.DateTimeFormat("en-US", {
    timeZone: ET_TZ, year: "numeric", month: "2-digit", day: "2-digit"
  }).format(new Date(d));
}
function fmtETTimeNoTZ(d) {
  // show Status as "MM/DD - h:MM AM/PM" (NO TZ and NO YEAR)
  const dateParts = new Intl.DateTimeFormat("en-US", {
    timeZone: ET_TZ, month: "2-digit", day: "2-digit", year: "numeric"
  }).formatToParts(new Date(d));
  const time = new Intl.DateTimeFormat("en-US", {
    timeZone: ET_TZ, hour: "numeric", minute: "2-digit", hour12: true
  }).format(new Date(d));
  const get = k => dateParts.find(p => p.type === k)?.value || "";
  return `${get("month")}/${get("day")} - ${time}`;
}

/* =========================
   ESPN ENDPOINTS
========================= */
const normLeague = (x) => (x === "ncaaf" || x === "college-football") ? "college-football" : "nfl";
const scoreboardUrl = (lg, dates) => {
  lg = normLeague(lg);
  const extra = lg === "college-football" ? "&groups=80&limit=300" : "";
  return `https://site.api.espn.com/apis/site/v2/sports/football/${lg}/scoreboard?dates=${dates}${extra}`;
};
const summaryUrl = (lg, eventId) =>
  `https://site.api.espn.com/apis/site/v2/sports/football/${normLeague(lg)}/summary?event=${eventId}`;

async function fetchJson(url) {
  log("GET", url);
  const r = await axios.get(url, { headers: { "User-Agent": "orchestrator" }, timeout: 15000 });
  return r.data;
}

/* =========================
   SHEETS HELPERS
========================= */
function mapHeadersToIndex(h) {
  const m = {};
  h.forEach((x, i) => (m[(x || "").trim().toLowerCase()] = i));
  return m;
}
function colLetter(i) {
  return String.fromCharCode("A".charCodeAt(0) + i);
}
class BatchWriter {
  constructor(tab, spreadsheetId, sheets) {
    this.tab = tab;
    this.spreadsheetId = spreadsheetId;
    this.sheets = sheets;
    this.acc = [];
  }
  add(row1, colIdx, value) {
    if (colIdx == null || colIdx < 0) return;
    const range = `${this.tab}!${colLetter(colIdx)}${row1}:${colLetter(colIdx)}${row1}`;
    this.acc.push({ range, values: [[value]] });
  }
  async flush() {
    if (!this.acc.length) return;
    await this.sheets.spreadsheets.values.batchUpdate({
      spreadsheetId: this.spreadsheetId,
      requestBody: { valueInputOption: "RAW", data: this.acc }
    });
    log(`Batched ${this.acc.length} update(s).`);
    this.acc = [];
  }
}

/* =========================
   HEADERS (A/H abbreviations)
========================= */
const COLS = [
  "Game ID", "Date", "Week", "Status", "Matchup", "Final Score",
  "A Spread", "A ML", "H Spread", "H ML", "Total",
  "H Score", "Half A Spread", "Half A ML", "Half H Spread", "Half H ML", "Half Total"
];

/* =========================
   STATUS CLEANUP
========================= */
function tidyStatusPregame(evtDateISO) {
  // Only used before kickoff; live updater owns live statuses
  return fmtETTimeNoTZ(evtDateISO);
}
function isFinalStatus(obj) {
  const t = (obj?.status?.type?.name || obj?.competitions?.[0]?.status?.type?.name || "").toUpperCase();
  return t.includes("FINAL");
}
function isLiveStatus(obj) {
  const t = (obj?.status?.type?.state || obj?.competitions?.[0]?.status?.type?.state || "").toUpperCase();
  return t === "IN";
}

/* =========================
   ODDS PARSING
========================= */
function pickOdds(arr = []) {
  if (!Array.isArray(arr)) return null;
  return arr.find(o => /espn\s*bet/i.test(o?.provider?.name || o?.provider?.displayName || "")) || arr[0] || null;
}
function toNum(x) {
  if (x == null) return null;
  const n = Number(String(x).replace(/[^\d.+-]/g, ""));
  return Number.isFinite(n) ? n : null;
}
function parsePregameOdds(oddsObj, away, home) {
  // returns { aSpread, hSpread, total, aML, hML, favSide: "away"|"home"|"" }
  let total = toNum(oddsObj?.overUnder ?? oddsObj?.total);
  // spread
  let spread = toNum(oddsObj?.spread);
  let favTeamId = String(oddsObj?.favoriteTeamId ?? oddsObj?.favorite ?? "");
  let aSpread = "", hSpread = "", favSide = "";

  if (Number.isFinite(spread) && favTeamId) {
    const abs = Math.abs(spread);
    if (String(away?.team?.id || "") === favTeamId) {
      aSpread = `-${abs}`; hSpread = `+${abs}`; favSide = "away";
    } else if (String(home?.team?.id || "") === favTeamId) {
      hSpread = `-${abs}`; aSpread = `+${abs}`; favSide = "home";
    }
  } else if (oddsObj?.details) {
    const m = String(oddsObj.details).match(/([+-]?\d+(?:\.\d+)?)/);
    if (m) {
      const line = Number(m[1]);
      // Unknown favorite — assume home favored when negative line in details like "SF -6.5"
      if (/^\s*[A-Za-z].*-\d/.test(oddsObj.details)) {
        hSpread = `-${Math.abs(line)}`; aSpread = `+${Math.abs(line)}`; favSide = "home";
      } else if (/^\s*[A-Za-z].*\+\d/.test(oddsObj.details)) {
        aSpread = `-${Math.abs(line)}`; hSpread = `+${Math.abs(line)}`; favSide = "away";
      } else {
        // default if truly unknown: away +line / home -line when negative
        if (line < 0) { hSpread = `${line}`; aSpread = `+${Math.abs(line)}`; favSide = "home"; }
        else { aSpread = `${line}`; hSpread = `-${Math.abs(line)}`; favSide = "away"; }
      }
    }
  }

  // moneylines
  const aML = toNum(
    oddsObj?.awayTeamOdds?.moneyLine ?? oddsObj?.awayTeamOdds?.moneyline ??
    oddsObj?.moneyline?.away?.close?.odds ?? oddsObj?.moneyline?.away?.open?.odds
  );
  const hML = toNum(
    oddsObj?.homeTeamOdds?.moneyLine ?? oddsObj?.homeTeamOdds?.moneyline ??
    oddsObj?.moneyline?.home?.close?.odds ?? oddsObj?.moneyline?.home?.open?.odds
  );

  return {
    aSpread: aSpread || "",
    hSpread: hSpread || "",
    total: total ?? "",
    aML: aML ?? "",
    hML: hML ?? "",
    favSide
  };
}

/* =========================
   SAFE UNDERLINE FOR FAVORITE
========================= */
async function underlineFavoriteInMatchup(sheets, sheetId, rowIndex1, colEindex, matchupText, favSide) {
  if (!matchupText || !/ @ /.test(matchupText)) return;

  const len = matchupText.length;
  const [awayName, homeName] = matchupText.split(" @ ");
  const awayStart = 0;
  const awayLen   = awayName.length;
  const homeStart = matchupText.indexOf(homeName);
  const homeLen   = homeName.length;
  if (homeStart < 0) return;

  const favStart = favSide === "home" ? homeStart : awayStart;
  const favLen   = favSide === "home" ? homeLen   : awayLen;
  const favEnd   = favStart + favLen;

  const rawRuns = [];
  if (favStart > 0) rawRuns.push({ startIndex: 0,       format: { underline: false } });
  if (favStart < len) rawRuns.push({ startIndex: favStart, format: { underline: true } });
  if (favEnd   < len) rawRuns.push({ startIndex: favEnd,   format: { underline: false } });

  // strictly ascending + < len
  const runs = [];
  let last = -1;
  for (const r of rawRuns) {
    if (Number.isFinite(r.startIndex) && r.startIndex > last && r.startIndex < len) {
      runs.push(r);
      last = r.startIndex;
    }
  }
  if (!runs.length) return;

  // 1) clear underline on the cell
  const clearReq = {
    updateCells: {
      range: {
        sheetId,
        startRowIndex: rowIndex1 - 1,
        endRowIndex: rowIndex1,
        startColumnIndex: colEindex,
        endColumnIndex: colEindex + 1
      },
      rows: [{
        values: [{ userEnteredFormat: { textFormat: { underline: false } } }]
      }],
      fields: "userEnteredFormat.textFormat.underline"
    }
  };

  // 2) write text + runs
  const writeReq = {
    updateCells: {
      range: {
        sheetId,
        startRowIndex: rowIndex1 - 1,
        endRowIndex: rowIndex1,
        startColumnIndex: colEindex,
        endColumnIndex: colEindex + 1
      },
      rows: [{
        values: [{
          userEnteredValue: { stringValue: matchupText },
          textFormatRuns: runs
        }]
      }],
      fields: "userEnteredValue,textFormatRuns"
    }
  };

  await sheets.spreadsheets.batchUpdate({
    spreadsheetId: SHEET_ID,
    requestBody: { requests: [clearReq, writeReq] }
  });
}

/* =========================
   MAIN
========================= */
(async function main() {
  if (!SHEET_ID || !CREDS_RAW) {
    const msg = "Missing GOOGLE_SHEET_ID or GOOGLE_SERVICE_ACCOUNT";
    if (GHA_JSON) { process.stdout.write(JSON.stringify({ ok: false, error: msg }) + "\n"); return; }
    throw new Error(msg);
  }
  const CREDS = parseServiceAccount(CREDS_RAW);
  const auth  = new google.auth.GoogleAuth({
    credentials: { client_email: CREDS.client_email, private_key: CREDS.private_key },
    scopes: ["https://www.googleapis.com/auth/spreadsheets"]
  });
  const sheets = google.sheets({ version: "v4", auth });

  // Ensure tab + header
  const meta = await sheets.spreadsheets.get({ spreadsheetId: SHEET_ID });
  const target = (meta.data.sheets || []).find(s => s.properties?.title === TAB_NAME);
  let sheetId = target?.properties?.sheetId;

  if (!target) {
    const add = await sheets.spreadsheets.batchUpdate({
      spreadsheetId: SHEET_ID,
      requestBody: { requests: [{ addSheet: { properties: { title: TAB_NAME } } }] }
    });
    sheetId = add.data.replies?.[0]?.addSheet?.properties?.sheetId;
  }

  const read = await sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID,
    range: `${TAB_NAME}!A1:Z`
  });
  const values = read.data.values || [];
  let header = values[0] || [];
  if (header.length === 0) {
    await sheets.spreadsheets.values.update({
      spreadsheetId: SHEET_ID,
      range: `${TAB_NAME}!A1`,
      valueInputOption: "RAW",
      requestBody: { values: [COLS] }
    });
    header = COLS.slice();
  }
  const hmap = mapHeadersToIndex(header);
  const rows = values.slice(1);

  // Build index by Game ID (A)
  const rowById = new Map();
  rows.forEach((r, i) => {
    const gid = String(r[hmap["game id"]] || "").trim();
    if (gid) rowById.set(gid, i + 2); // 1-based row
  });

  // date list
  const today = new Date();
  const dates = RUN_SCOPE === "week"
    ? Array.from({ length: 7 }, (_, i) => fmtETDateYYYYMMDD(new Date(today.getTime() + i * 86400000)))
    : [fmtETDateYYYYMMDD(today)];

  // optional target IDs
  const forcedIds = TARGET_ID_RAW
    ? TARGET_ID_RAW.split(",").map(s => s.trim()).filter(Boolean)
    : [];

  // Collect events
  let events = [];
  for (const d of dates) {
    const sb = await fetchJson(scoreboardUrl(LEAGUE, d));
    if (Array.isArray(sb?.events)) events.push(...sb.events);
  }
  // Dedup
  const seen = new Set();
  events = events.filter(e => !seen.has(e.id) && seen.add(e.id));

  // If forced list present, keep only those
  if (forcedIds.length) events = events.filter(e => forcedIds.includes(String(e.id)));

  log("Events found:", events.length);

  // Append missing rows (prefill)
  const append = [];
  for (const ev of events) {
    const comp = ev.competitions?.[0] || {};
    const away = comp.competitors?.find(c => c.homeAway === "away");
    const home = comp.competitors?.find(c => c.homeAway === "home");
    const awayName = away?.team?.shortDisplayName || away?.team?.abbreviation || away?.team?.name || "Away";
    const homeName = home?.team?.shortDisplayName || home?.team?.abbreviation || home?.team?.name || "Home";
    const matchup = `${awayName} @ ${homeName}`;

    if (!rowById.has(String(ev.id))) {
      // pregame line (from odds)
      const oddsObj = pickOdds(comp.odds || ev.odds || []);
      const parsed = oddsObj ? parsePregameOdds(oddsObj, away, home) : {};
      const status = tidyStatusPregame(ev.date); // pregame only
      const dateForB = fmtETDateMDY(ev.date);
      append.push([
        String(ev.id),          // A: Game ID
        dateForB,               // B: Date
        (ev.week?.text || ev.week?.number ? `Week ${ev.week?.number ?? ev.week?.text}` : ""), // C
        status,                 // D: Status (pregame date/time)
        matchup,                // E
        "",                     // F: Final Score
        parsed?.aSpread ?? "",  // G: A Spread
        parsed?.aML ?? "",      // H: A ML
        parsed?.hSpread ?? "",  // I: H Spread
        parsed?.hML ?? "",      // J: H ML
        parsed?.total ?? "",    // K: Total
        "", "", "", "", "", ""  // L..Q (half columns)
      ]);
    }
  }
  if (append.length) {
    await sheets.spreadsheets.values.append({
      spreadsheetId: SHEET_ID,
      range: `${TAB_NAME}!A1`,
      valueInputOption: "RAW",
      requestBody: { values: append }
    });
    // refresh rowById
    const reread = await sheets.spreadsheets.values.get({
      spreadsheetId: SHEET_ID, range: `${TAB_NAME}!A1:Z`
    });
    const vals2 = reread.data.values || [];
    const hdr2 = vals2[0] || header;
    const hm2 = mapHeadersToIndex(hdr2);
    (vals2.slice(1)).forEach((r, i) => {
      const gid = String(r[hm2["game id"]] || "").trim();
      if (gid) rowById.set(gid, i + 2);
    });
  }

  // PASS: update pregame lines (only if not live and not final), bold winner at finals, underline favorite
  const bw = new BatchWriter(TAB_NAME, SHEET_ID, sheets);

  for (const ev of events) {
    const row1 = rowById.get(String(ev.id));
    if (!row1) continue;

    const comp = ev.competitions?.[0] || {};
    const away = comp.competitors?.find(c => c.homeAway === "away");
    const home = comp.competitors?.find(c => c.homeAway === "home");
    const awayName = away?.team?.shortDisplayName || away?.team?.abbreviation || away?.team?.name || "Away";
    const homeName = home?.team?.shortDisplayName || home?.team?.abbreviation || home?.team?.name || "Home";
    const matchup = `${awayName} @ ${homeName}`;

    const statusIsFinal = isFinalStatus(ev);
    const statusIsLive  = isLiveStatus(ev);

    // Prefill status only prior to kickoff (do not overwrite once live)
    if (!statusIsLive && !statusIsFinal) {
      const status = tidyStatusPregame(ev.date);
      if (hmap["status"] !== undefined) bw.add(row1, hmap["status"], status);
    }

    // Pregame lines refresh (before kickoff)
    if (!statusIsLive && !statusIsFinal) {
      const oddsObj = pickOdds(comp.odds || ev.odds || []);
      if (oddsObj) {
        const parsed = parsePregameOdds(oddsObj, away, home);
        if (hmap["a spread"] !== undefined && parsed.aSpread !== undefined) bw.add(row1, hmap["a spread"], String(parsed.aSpread || ""));
        if (hmap["h spread"] !== undefined && parsed.hSpread !== undefined) bw.add(row1, hmap["h spread"], String(parsed.hSpread || ""));
        if (hmap["a ml"] !== undefined     && parsed.aML     !== undefined) bw.add(row1, hmap["a ml"], String(parsed.aML || ""));
        if (hmap["h ml"] !== undefined     && parsed.hML     !== undefined) bw.add(row1, hmap["h ml"], String(parsed.hML || ""));
        if (hmap["total"] !== undefined    && parsed.total   !== undefined) bw.add(row1, hmap["total"], String(parsed.total || ""));

        // underline favorite (safe writer)
        if (parsed.favSide) {
          // E column index (zero-based)
          const colE = hmap["matchup"];
          try {
            await underlineFavoriteInMatchup(sheets, sheetId, row1, colE, matchup, parsed.favSide);
          } catch (e) {
            warn("underline favorite failed:", e?.message || e);
          }
        }
      }
    }

    // Finals: set final score & bold winner only
    if (statusIsFinal) {
      const finalScore = `${away?.score ?? ""}-${home?.score ?? ""}`;
      if (hmap["final score"] !== undefined) bw.add(row1, hmap["final score"], finalScore);

      // bold winner in matchup (keep underline from pregame)
      const winnerSide = Number(away?.score ?? 0) > Number(home?.score ?? 0) ? "away"
        : Number(home?.score ?? 0) > Number(away?.score ?? 0) ? "home" : "";
      if (winnerSide) {
        const colE = hmap["matchup"];
        const len = matchup.length;
        const [aName, hName] = matchup.split(" @ ");
        const aStart = 0, aLen = aName.length;
        const hStart = matchup.indexOf(hName), hLen = hName.length;

        const wStart = winnerSide === "home" ? hStart : aStart;
        const wLen   = winnerSide === "home" ? hLen   : aLen;
        const wEnd   = wStart + wLen;

        // compose textFormatRuns: keep underline as-is, add bold on winner segment
        const runs = [];
        // default off
        if (0 < len) runs.push({ startIndex: 0, format: { underline: false, bold: false } });
        // favorite underline may have been present; we don’t try to re-derive it here.
        // Just apply bold over winner window.
        if (wStart < len) runs.push({ startIndex: wStart, format: { bold: true } });
        if (wEnd   < len) runs.push({ startIndex: wEnd,   format: { bold: false } });

        // sanitize ascending
        const asc = [];
        let last = -1;
        for (const r of runs) {
          if (r.startIndex > last && r.startIndex < len) { asc.push(r); last = r.startIndex; }
        }

        // update cell
        await sheets.spreadsheets.batchUpdate({
          spreadsheetId: SHEET_ID,
          requestBody: {
            requests: [{
              updateCells: {
                range: {
                  sheetId,
                  startRowIndex: row1 - 1, endRowIndex: row1,
                  startColumnIndex: colE, endColumnIndex: colE + 1
                },
                rows: [{
                  values: [{
                    userEnteredValue: { stringValue: matchup },
                    textFormatRuns: asc
                  }]
                }],
                fields: "userEnteredValue,textFormatRuns"
              }
            }]
          }
        });
      }
    }
  }

  await bw.flush();

  log("Run complete.");
  if (GHA_JSON) process.stdout.write(JSON.stringify({ ok: true, league: normLeague(LEAGUE), tab: TAB_NAME }) + "\n");
})().catch(err => {
  warn("❌ Error:", err?.stack || err?.message || String(err));
  if (GHA_JSON) process.stdout.write(JSON.stringify({ ok: false, error: String(err?.message || err) }) + "\n");
  process.exit(1);
});
